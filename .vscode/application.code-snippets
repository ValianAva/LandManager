{
	"Empty CQRS Query": {
		"scope": "csharp",
		"prefix": "EmptyCQRSQuery",
		"body": [
			"",
			"namespace LandManager.Application.${1:LandManager}.${2:Entity}s.Queries.${3:QueryName};",
			"",
			"public class $3Query : IQuery<IList<${4:DtoType}>>",
			"{",
			"}",
			"",
			"public class $3QueryHandler : IRequestHandler<$3Query, IList<$4>>",
			"{",
			"\tprivate readonly IAppContext _context;",
			"\tprivate readonly IMapper _mapper;",
			"\tprivate readonly ILogger _logger;",
			"\t",
			"\tpublic $3QueryHandler(IAppContext context, IMapper mapper, ILogger logger)",
			"\t{",
			"\t\t_context = context;",
			"\t\t_mapper = mapper;",
			"\t\t_logger = logger.ForContext(\"SourceContext\", GetType().Name);",
			"\t}",
			"\t",
			"\tpublic async Task<IList<$4>> Handle($3Query request, CancellationToken cancellationToken)",
			"\t{",
			"\t\tvar entities = await _context.$2.ProjectTo<$4>(_mapper.ConfigurationProvider).ToListAsync(cancellationToken);",
			"\t\t_logger.Debug(\"Returning {$2Count} $2s\", entities.Count);",
			"\t\treturn entities;",
			"\t}",
			"}"
		],
		"description": "An empty (parameter-less) query and its handler, following the CQRS pattern"
	},
	"Single CQRS Query": {
		"scope": "csharp",
		"prefix": "SingleCQRSQuery",
		"body": [
			"namespace LandManager.Application.${1:LandManager}.${2:Entity}s.Queries.${3:QueryName};",
			"",
			"public class $3Query : IQuery<${4:DtoType}>",
			"{",
			"\tpublic int Id { get; set; }",
			"}",
			"",
			"public class $3QueryHandler : IRequestHandler<$3Query, $4>",
			"{",
			"\tprivate readonly IAppContext _context;",
			"\tprivate readonly IMapper _mapper;",
			"\tprivate readonly ILogger _logger;",
			"\t",
			"\tpublic $3QueryHandler(IAppContext context, IMapper mapper, ILogger logger)",
			"\t{",
			"\t\t_context = context;",
			"\t\t_mapper = mapper;",
			"\t\t_logger = logger.ForContext(\"SourceContext\", GetType().Name);",
			"\t}",
			"\t",
			"\tpublic async Task<$4> Handle($3Query request, CancellationToken cancellationToken)",
			"\t{",
			"\t\tvar entity = await _context.$2.ProjectTo<$4>(_mapper.ConfigurationProvider).FirstOrDefaultAsync(a => a.Id == request.Id, cancellationToken);",
			"\t\t",
			"\t\tif (entity == null)",
			"\t\t{",
			"\t\t\t_logger.Warning(\"$2 {$2Id} not found. Throwing NotFoundException\", request.Id);",
			"\t\t\tthrow new NotFoundException(nameof($2), request.Id);",
			"\t\t}",
			"\t\t",
			"\t\t_logger.Debug(\"Returning details for $2 {$2Id} with name {$2Name}\", entity.Id, entity.Name);",
			"\t\treturn entity;",
			"\t}",
			"}"
		],
		"description": "An query that takes an id and its handler that gets the first matching entity, following the CQRS pattern"
	},
	"Query Validator": {
		"scope": "csharp",
		"prefix": "QueryValidator",
		"body": [
			"using FluentValidation;",
			"",
			"namespace LandManager.Application.${1:LandManager}.${2:Entity}s.Queries.${3:QueryName};",
			"",
			"public class $3QueryValidator : AbstractValidator<$3Query>",
			"{",
			"\tpublic $3QueryValidator()",
			"\t{",
			"\t\t$0",
			"\t}",
			"}"
		],
		"description": "A validator for a CQRS query"
	},
	"Add CQRS Command": {
		"scope": "csharp",
		"prefix": "AddCommand",
		"body": [
			"namespace LandManager.Application.${1:LandManager}.${2:Entity}s.Commands.${3:CommandName};",
			"",
			"public class $3Command : ICommand<int>, IHaveCustomMapping",
			"{",
			"\t$0",
			"\t",
			"\tpublic void CreateMappings(Profile configuration)",
			"\t{",
			"\t\tconfiguration.CreateMap<$3Command, $2>();",
			"\t}",
			"}",
			"",
			"public class $3CommandHandler : IRequestHandler<$3Command, int>",
			"{",
			"\tprivate readonly IAppContext _context;",
			"\tprivate readonly IMapper _mapper;",
			"\tprivate readonly ILogger _logger;",
			"\t",
			"\tpublic $3CommandHandler(IAppContext context, IMapper mapper, ILogger logger)",
			"\t{",
			"\t\t_context = context;",
			"\t\t_mapper = mapper;",
			"\t\t_logger = logger.ForContext(\"SourceContext\", GetType().Name);",
			"\t}",
			"\t",
			"\tpublic async Task<int> Handle($3Command request, CancellationToken cancellationToken)",
			"\t{",
			"\t\t// map to domain model",
			"\t\t$2 entity = _mapper.Map<$2>(request);",
			"\t\t",
			"\t\t// save to database",
			"\t\t_context.$2.Add(entity);",
			"\t\tawait _context.SaveChangesAsync(cancellationToken);",
			"\t\t_logger.Information(\"Added $2 {$2Id} to database\", entity.Id);",
			"\t\t",
			"\t\treturn entity.Id;",
			"\t}",
			"}"
		],
		"description": "A CQRS add command that persists the entity"
	},
	"Update CQRS Command": {
		"scope": "csharp",
		"prefix": "UpdateCommand",
		"body": [
			"namespace LandManager.Application.${1:LandManager}.${2:Entity}s.Commands.${3:CommandName};",
			"",
			"public class $3Command : ICommand<int>, IHaveCustomMapping",
			"{",
			"\tpublic int Id {get; set;}",
			"\t$0",
			"\tpublic void CreateMappings(Profile configuration)",
			"\t{",
			"\t\tconfiguration.CreateMap<$3Command, $2>();",
			"\t}",
			"}",
			"",
			"public class $3CommandHandler : IRequestHandler<$3Command, int>",
			"{",
			"\tprivate readonly IAppContext _context;",
			"\tprivate readonly IMapper _mapper;",
			"\tprivate readonly ILogger _logger;",
			"\t",
			"\tpublic $3CommandHandler(IAppContext context, IMapper mapper, ILogger logger)",
			"\t{",
			"\t\t_context = context;",
			"\t\t_mapper = mapper;",
			"\t\t_logger = logger.ForContext(\"SourceContext\", GetType().Name);",
			"\t}",
			"\t",
			"\tpublic async Task<int> Handle($3Command request, CancellationToken cancellationToken)",
			"\t{",
			"\t\t// find in database",
			"\t\t$2 entity = _context.$2.Find(request.Id);",
			"\t\t",
			"\t\tif (entity == null) {",
			"\t\t\t_logger.Warning(\"$2 {$2Id} not found in database. Throwing NotFoundException.\", request.Id);",
			"\t\t\tthrow new NotFoundException(nameof($2), request.Id);",
			"\t\t}",
			"\t\t// map to domain model",
			"\t\t_mapper.Map(request, entity);",
			"\t\t",
			"\t\t// save to database",
			"\t\t_context.$2.Update(entity);",
			"\t\tawait _context.SaveChangesAsync(cancellationToken);",
			"\t\t_logger.Information(\"$2 {$2Id} updated in database.\", entity.Id);",
			"\t\t",
			"\t\treturn entity.Id;",
			"\t}",
			"}"
		],
		"description": "A CQRS add command that persists the entity"
	},
	"Delete CQRS Command": {
		"scope": "csharp",
		"prefix": "DeleteCommand",
		"body": [
			"namespace LandManager.Application.${1:LandManager}.${2:Entity}s.Commands.${3:CommandName};",
			"",
			"public class $3Command : ICommand<int>",
			"{",
			"\tpublic int Id {get; set;}",
			"}",
			"",
			"public class $3CommandHandler : IRequestHandler<$3Command, int>",
			"{",
			"\tprivate readonly IAppContext _context;",
			"\tprivate readonly IMapper _mapper;",
			"\tprivate readonly ILogger _logger;",
			"\t",
			"\tpublic $3CommandHandler(IAppContext context, IMapper mapper, ILogger logger)",
			"\t{",
			"\t\t_context = context;",
			"\t\t_mapper = mapper;",
			"\t\t_logger = logger.ForContext(\"SourceContext\", GetType().Name);",
			"\t}",
			"\t",
			"\tpublic async Task<int> Handle($3Command request, CancellationToken cancellationToken)",
			"\t{",
			"\t\t// find in database",
			"\t\t$2 entity = _context.$2.Find(request.Id);",
			"\t\t",
			"\t\tif (entity == null) {",
			"\t\t\t_logger.Warning(\"$2 {$2Id} not found in database. Throwing NotFoundException.\", request.Id);",
			"\t\t\tthrow new NotFoundException(nameof($2), request.Id);",
			"\t\t}",
			"\t\t// delete from database",
			"\t\t_context.$2.Remove(entity);",
			"\t\tawait _context.SaveChangesAsync(cancellationToken);",
			"\t\t_logger.Information(\"$2 {$2Id} removed from database.\", entity.Id);",
			"\t\t",
			"\t\treturn request.Id;",
			"\t}",
			"}"
		],
		"description": "A CQRS delete command that removes the entity"
	},
	"Command Validator": {
		"scope": "csharp",
		"prefix": "CommandValidator",
		"body": [
			"using FluentValidation;",
			"",
			"namespace LandManager.Application.${1:LandManager}.${2:Entity}s.Commands.${3:CommandName};",
			"",
			"public class $3CommandValidator : AbstractValidator<$3Command>",
			"{",
			"\tpublic $3CommandValidator()",
			"\t{",
			"\t\t$0",
			"\t}",
			"}"
		],
		"description": "A validator for a CQRS command"
	},
	"Command Notification Handler": {
		"scope": "csharp",
		"prefix": "CommandNotificationHandler",
		"body": [
			"namespace LandManager.Application.${1:LandManager}.${2:EntityNamespace}s.Commands.${3:CommandName};",
			"",
			"public class ${TM_FILENAME_BASE} : INotification",
			"{",
			"\t// what the notification handler needs to get its job done",
			"\t$0",
			"\t",
			"\tpublic class ${TM_FILENAME_BASE}Handler : INotificationHandler<${TM_FILENAME_BASE}>",
			"\t{",
			"\t\tprivate readonly ISearcher _searcher;",
			"\t\tpublic ${TM_FILENAME_BASE}Handler(ISearcher searcher)",
			"\t\t{",
			"\t\t\t_searcher = searcher;",
			"\t\t}",
			"\t\t",
			"\t\tpublic async Task Handle(${TM_FILENAME_BASE} notification, CancellationToken cancellationToken)",
			"\t\t{",
			"\t\t\t",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "A notification handler for a CQRS command"
	},
	"Not Null Validator": {
		"scope": "csharp",
		"prefix": "notNullValidator",
		"body": [
			"RuleFor(e => e.$1)",
			"\t.NotNull().WithMessage(\"$1 is required\");"
		],
		"description": "A validator rule for a not null property"
	},
	"Not Empty Validator": {
		"scope": "csharp",
		"prefix": "notEmptyValidator",
		"body": [
			"RuleFor(e => e.$1)",
			"\t.NotEmpty().WithMessage(\"$1 is required\");"
		],
		"description": "A validator rule for a not empty property"
	}
}
